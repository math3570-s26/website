---
title: "Visualizing Data `r emo::ji('chart_with_upwards_trend')`"
title-slide-attributes:
  data-background-image: ../images/bg.png
  # data-background-size: stretch
  # data-slide-number: none
format: 
  live-revealjs: 
    output-file: 10-viz-slides.html
    df-print: default
webr:
  cell-options:
    autorun: false
  packages:
    - tidyverse
execute: 
  echo: true
---

#  {visibility="hidden"}

\def\bx{\mathbf{x}}
\def\bg{\mathbf{g}}
\def\bw{\mathbf{w}}
\def\bbeta{\boldsymbol \beta}
\def\bX{\mathbf{X}}
\def\by{\mathbf{y}}
\def\bH{\mathbf{H}}
\def\bI{\mathbf{I}}
\def\bS{\mathbf{S}}
\def\bW{\mathbf{W}}
\def\T{\text{T}}
\def\cov{\mathrm{Cov}}
\def\cor{\mathrm{Corr}}
\def\var{\mathrm{Var}}
\def\E{\mathrm{E}}
\def\bmu{\boldsymbol \mu}
\DeclareMathOperator*{\argmin}{arg\,min}
\def\Trace{\text{Trace}}

```{r}
#| label: setup
#| include: false
#| eval: true
library(countdown)
library(emo)
library(knitr)
library(gt)
library(gtExtras)
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(fontawesome)
library(rmarkdown)
library(reticulate)
library(lattice)
library(hexbin)
# library(ISLR2)
# library(genridge)
# library(glmnet)
# library(gam)
# library(splines)
# library(MASS)

# library(ElemStatLearn)
knitr::opts_chunk$set(
    fig.asp = 0.618,
    fig.align = "center",
    out.width = "100%",
    fig.retina = 10,
    fig.path = "images/10-viz/",
    message = FALSE,
    global.par = TRUE
)
options(
  htmltools.dir.version = FALSE,
  dplyr.print_min = 8, 
  dplyr.print_max = 9,
  tibble.width = 80,
  width = 80,
  digits = 3
  )
hook_output <- knitr::knit_hooks$get("output")
knitr::knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }
  # paste these lines together
  x <- paste(c(x, ""), collapse = "\n")
  hook_output(x, options)
})
```

```{python}
#| eval: false
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| purl: false
#| label: packages
library(tidyverse)
library(openintro)
loans_full_schema <- loans_full_schema |> mutate(grade = factor(grade, ordered = TRUE))
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| purl: false
knitr::opts_knit$set(global.par = TRUE)
```

## Categorical vs. Numerical Variables

-   A **categorical (qualitative)** variable provides *non-numerical* information which can be placed in **one (and only one)** category from two or more categories.

::: fragment
-   [Gender (Male `r emo::ji('man')`, Female `r emo::ji('woman')`, Other `r emo::ji('rainbow_flag')`) ]{style="color:blue"}
-   [Class (Freshman, Sophomore, Junior, Senior, Graduate) ]{style="color:blue"}
-   [Country (USA `r emo::ji('us')`, Canada `r emo::ji('canada')`, UK `r emo::ji('uk')`, Germany `r emo::ji('de')`, Japan `r emo::ji('jp')`, Korea `r emo::ji('kr')`) ]{style="color:blue"}
:::

. . .

-   A **numerical (quantitative)** variable is recorded in a *numerical* value representing counts or measurements.

::: fragment
-   [ GPA ]{style="color:blue"}
-   [ The number of relationships you've had ]{style="color:blue"}
-   [ Height ]{style="color:blue"}
:::

## Data: Lending Club

-   [Lending Club](https://www.lendingclub.com/) is a platform that allows individuals to lend to other individuals.

-   *Not all loans are created equal* -- ease of getting a loan depends on ability to pay back the loan.

-   Data includes **loans made**, these are not loan applications.

```{r}
#| echo: false
#| label: lending-club
#| out-width: 70%
knitr::include_graphics("./images/10-viz/lending-club.png")
```

::: notes
-   OK. The data set we will be working with comes from the lending club.
-   Thousands of loans made through the Lending Club, which is a platform that allows individuals to lend to other individuals.
-   If you are finance or econ major, or you know about loans, you know that Not all loans are created equal -- ease of getting a loan depends on (apparent) ability to pay back the loan.
-   Data include loans *made*, these are not loan applications.
-   It's important to keep this in mind when we are looking at the relationships between the variables that we are going to see, since the pattern may be different for those relationships for loans that never got approved.
:::

## Take a Peek at Data

```{r}
#| label: loans_full_schema
#| cache: true
#| class-output: my_class800
#| code-line-numbers: true
library(openintro) ## for loading the data set
dplyr::glimpse(loans_full_schema)
```

::: notes
-   The data set is stored in the openintro package.
-   In addition to head, structure function, we can also use glimpse() function to see the general picture of the data.
-   We can see that we have 10000 rows, so there are 10000 observations, or loans made in the data set.
-   And there are 55 columns.
-   And the name of the data set is loans_full_schema.
:::

## Selected Variables

```{r}
#| label: loans
#| cache: true
#| code-line-numbers: false
loans <- loans_full_schema |> 
    dplyr::select(loan_amount, 
                  interest_rate, 
                  grade, 
                  homeownership, 
                  debt_to_income)
glimpse(loans)
```

::: notes
-   There are 55 variables in the data, but our visualization purpose, we are only going to focus on 8 of these columns.
-   loan_amount, ..., debt_to_income ratio
-   I piped the data into the select function, which allows me to select variables I want by name, and called the selected data loans.
-   So the data has all 10000 observations and 8 selected variables.
:::

## Variable Description

<br>

| variable | description |
|---------------------------------------|--------------------------------|
| `loan_amount` | Amount of the loan received, in US dollars |
| `interest_rate` | Interest rate on the loan, in an annual percentage |
| `grade` | Loan grade, which takes a values A through G and represents the quality of the loan |
| `homeownership` | Indicates whether the person owns, owns but has a mortgage, or rents |
| `debt_to_income` | Debt-to-income ratio |

## Variable Types

<br>

| variable         | type                  |
|------------------|-----------------------|
| `loan_amount`    | numerical, continuous |
| `interest_rate`  | numerical, continuous |
| `grade`          | categorical, ordinal  |
| `homeownership`  | categorical, nominal  |
| `debt_to_income` | numerical, continuous |

# Visualizing Categorical Data {background-color="#A7D5E8"}

## [Bar Chart](https://ggplot2.tidyverse.org/reference/geom_bar.html)

-   A bar chart shows the **frequency table** of a **categorical** variable.

```{r}
#| label: geom_bar
#| out-width: 62%
#| cache: true
#| code-line-numbers: false
## geom_bar(stat = "count")
loans |> ggplot(aes(x = homeownership)) +
    geom_bar()  #<<
```

::: notes
-   One way representing categorical data is using bar plot.
-   Here we don't use geom_point anymore. Instead, we use the geom_bar function.
-   Here we would like to see the frequency distribution of variable homeownership, so I map x to the homeownership variable.
-   When the geom_bar() is called. ggplot2 actually counts the number of each category for us. In other words, ggplots automatically creates the frequency table of homeownership for us, telling us how many observations belong to mortgage, how many belong to own and how many belong to rent.
-   So the question is, Where does count come from? How does ggplot2 do the calculation?
-   Note that on the y-axis, it displays **count**, but count is NOT a variable in `loans`!
-   Where does count come from?
:::

## Statistical Transformations {visibility="hidden"}

-   Bar charts calculate new values to plot.

-   The algorithm used to calculate new values is called a **stat**, short for *statistical transformation*.

-   In short, ggplot2 calculate the frequency table of homeownership `table(homeownership)`, and save "count" as default value for **stat**.

-   It means that `geom_bar()` uses `stat_count()`.

```{r, out.width="40%", cache=TRUE, purl=FALSE}
#| eval: false
ggplot(loans, aes(x = homeownership)) +
    stat_count()  #<<
```

## Stacked Bar Chart {visibility="hidden"}

:::::: columns
::: {.column width="52%"}
```{r}
#| label: freq_tbl
#| code-line-numbers: false

(tbl <- table(loans$homeownership))

(freq_tbl <- as.data.frame(tbl[3:5]))

## column names
names(freq_tbl) <- c("type","count")
freq_tbl
```

<!-- # ```{r} -->

<!-- # class(freq_tbl) -->

<!-- # ``` -->
:::

:::: {.column width="48%"}
::: fragment
```{r}
#| label: geom_bar_identity
#| out-width: 100%
#| code-line-numbers: false
bar <- freq_tbl |> 
    ggplot(aes(x = "", 
               y = count, 
               fill = type)) + 
    geom_bar(stat = "identity")
bar
```
:::
::::
::::::

::: notes
-   Check the proportion or percentage of each category, we may want to create a stacked bar chart.
-   To create such plot, we need to prepare a frequency table.
-   x = "" because we don't map any variable in the frequency table data.
-   fill = type because we are gonna fill the bar with colors by the type of homeownership.
-   stat = "identity" because here we don't need to calculate the counts of each category, "identity" means using the values provided in the data.
-   geom_bar() uses stat_count() by default: it counts the number of cases at each x position. geom_col() uses stat_identity(): it leaves the data as is.

bar + theme_minimal() + labs(x = "") ggplot(freq_tbl, aes(x = "", y = count, color = type)) + geom_bar(stat = "identity")
:::

## Stacked Bar Chart and [Pie Chart](https://ggplot2.tidyverse.org/reference/coord_polar.html)

::::::: columns
::: {.column width="50%"}
```{r}
#| label: stacked_bar
#| out-width: 100%
#| code-line-numbers: false
stacked_bar <- 
    ggplot(loans, 
           aes(x = "", 
               fill = homeownership)) +
    geom_bar()
stacked_bar
```

<!-- # ```{r} -->

<!-- # class(freq_tbl) -->

<!-- # ``` -->
:::

::::: {.column width="50%"}
:::: fragment
```{r}
#| label: stacked_bar_polar
#| out-width: 100%
#| code-line-numbers: false
pie <- stacked_bar + 
    coord_polar(theta = "y")
pie
```

::: question
How do we remove the axes and background?
:::
::::
:::::
:::::::

## [Pie Chart](https://ggplot2.tidyverse.org/reference/coord_polar.html) {visibility="hidden"}

:::::: columns
::: {.column width="50%"}
```{r}
#| label: pie
#| out-width: 100%
#| code-line-numbers: false
pie <- bar + 
    coord_polar(theta = "y")
pie
```
:::

:::: {.column width="50%"}
::: fragment
```{r}
#| label: pie_void
#| out-width: 100%
#| code-line-numbers: false
pie + theme_void()
```
:::
::::
::::::

::: notes
theta = variable to map angle to (x or y) Offset of starting point from 12 o'clock in radians. pie + geom_text(aes(label = count), position = position_stack(vjust = 0.5))
:::

## Segmented Bar Plot: Stacked

```{r}
#| label: bar_stacked
#| out-width: 75%
#| code-line-numbers: false
loans |> ggplot(aes(x = homeownership, 
                    fill = grade)) + #<<
    geom_bar()
```

::: notes
-   We can use Segmented Bar Plot, which is helpful when you want to represent two variables.
-   So here we fill these bars based on the grade of the loan, which we know ranges from A to G.
-   So each one of theses segments tells us how many of that grade of loan was observed within a particular homeownership.
:::

## Segmented Bar Plot: Compare Proportions

-   `position = "fill"` makes each set of stacked bars the *same height*.

```{r}
#| label: bar_pos_fill
#| out-width: 68%
#| code-line-numbers: false
loans |> ggplot(aes(x = homeownership, fill = grade)) +
    geom_bar(position = "fill") #<<
```

::: notes
-   We may want to add another argument in the geom_bar layer, which is position = "fill".
-   `position = "fill"` works like stacking, but makes each set of stacked bars the same height.
-   And now the y-axis is not count anymore. Now the y limit is from 0 to 1, and each grade segment represents the relative frequency of a particular homeownership.
-   Which bar plot is a more useful representation for visualizing the relationship between homeownership and grade?
:::

##  {visibility="hidden"}

::: question
Which bar plot is a more useful representation for visualizing the relationship between homeownership and grade?
:::

::::: columns
::: {.column width="50%"}
```{r}
#| echo: false
#| out-width: 100%
#| purl: false
#| code-line-numbers: false
ggplot(loans, aes(x = homeownership, fill = grade)) +
  geom_bar()
```
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| out-width: 100%
#| purl: false
ggplot(loans, aes(x = homeownership, fill = grade)) +
  geom_bar(position = "fill")
```
:::
:::::

::: notes
-   Well that will be the one makes each set of stacked bars the same height.
-   This way, we can more easily compare the relative frequency or proportions of grade of loan for each type of homeownership.
-   So for example, we can see that the A grade loan, which is the highest quality grade, are more common among people who either mortgage their house or own their house, but slightly less common among renters, which maybe makes sense, because if you already own your house, or you are paying mortgage, it means that somebody has already done a credit check on you, and you probably passed that, so maybe you are more reliable for paying back your loan, so you are more eligible for the higher grade of loan.
:::

## Segmented Bar Plot: Compare Individual Values

-   `position = "dodge"` places overlapping objects directly *beside* one another.

```{r}
#| label: bar_pos_dodge
#| out-width: 60%
#| code-line-numbers: false
loans |> ggplot(aes(x = homeownership, fill = grade)) +
  geom_bar(position = "dodge") #<<
```

::: notes
-   If you wanna compare Individual Values, here the individual category of the grade of loan in each ownership type, `position = "dodge"` may be a goo option.
-   The option places the grade of loans directly *beside* one another.
-   This way, it's easier to see the counts of grade of loan within each ownership.
:::

## Customizing Bar Plots {visibility="hidden"}

:::::: columns
:::: {.column width="35%"}
::: midi
```{r}
#| label: bar-custom
#| fig-show: hide
#| warning: false
#| cache: true
#| class-source: my_class800
#| code-line-numbers: true

loans |> 
  ggplot(
    aes(x = homeownership,
        fill = homeownership)
  ) + 
  geom_bar(
    color = "blue", 
    width = 0.2, 
    alpha = 0.5
  ) + 
  labs(
    x = "Homeownership", 
    title = "Homeownership Counts"
  ) +
  geom_text(
    aes(label = after_stat(count)), 
        stat = 'count', 
        hjust = 3, 
        color = "red", 
        size = 5
  ) + 
  theme_minimal() + 
  coord_flip() ## y = homeownership
```
:::
::::

::: {.column width="65%"}
-   `ggplot2::geom_bar()`

-   `ggplot2::geom_text()`

```{r ref.label = "bar-custom"}
#| echo: false
#| warning: false
#| out-width: 100%
#| cache: true
#| purl: false
```
:::
::::::

::: notes
-   [**stat**](https://ggplot2.tidyverse.org/reference/#section-stats) is short for *statistical transformation*.
-   `stat = 'count'` uses the `stat_count()` method to get the count of each homeownership.
-   One reason why ggplot2 is powerful is you can customize your plot with great flexibility.
-   When you use aesthetic option fill, each bar will be colored according to the variable we assign.
-   Because here x and fill map to the same variable, we have each bar has its own one color.
-   We can specify some settings in geom_bar. color is the color of the edge of the bar, and we can also control the width and transparency of bars.
-   We know labs already.
-   If you wanna add text other then labels to your plot, you can use geom_text() function.
-   If you wanna add the counts on each bar, you map label to the variable ..count..
-   When you see the the variable or data has ..variable_name.., it means that it is an interval variable created by ggplot2.
-   In order to use this ..count.. internal variable, we have to set the stat transformation = "count.
-   And we can adjust the text horizontally through \[hjust\], and we can also specify its color and size as we usually do.
-   Finally I use theme_minimal() and I flip the coordinate so that the bars become horizontal. It is the same as y = homeownership
:::

# Visualizing Numerical Data {background-color="#A7D5E8"}

## Histogram

```{r}
#| label: hist
#| message: true
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
loans |> ggplot(aes(x = loan_amount)) +
    geom_histogram() #<<
```

::: notes
-   One of the most commonly used ways of visualizing numerical data is with histograms.
-   In ggplot2, we use geom_histogram to create a histogram.
-   When you use this function, ggplot2 send you a message saying that it uses 30 bins, or the number of classes created from the data, each representing one coloumn in the histogram.
-   And you can pick better value with `binwidth`, or the class width.
:::

## 

::: panel-tabset
## binwidth = 1000

```{r}
#| label: hist-1000
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_histogram(binwidth = 1000)
```

## binwidth = 5000

```{r}
#| label: hist-5000
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_histogram(binwidth = 5000)
```

## binwidth = 20000

```{r}
#| label: hist-20000
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_histogram(binwidth = 20000)
```
:::

::: notes
-   In this plot I use a binwidth of a thousand dollars, so each one of the bars represents a range of thousand dollars, and the heights of these bars tell me how many loans fall into that range.
-   In the second plot, the binwidth is 500 thousand dollars. So here we can have better sense of the shape of the distribution, comparing to the previous one.
-   The last plot use the binwidth 20000 dollars. And now we lose anything interesting about the shape of the distribution.
-   So picking a binwidth or the number of bins is an art and science. But try 10 to 20 bins may be a good start.
:::

## Customizing Histograms {visibility="hidden"}

::::: columns
::: {.column width="40%"}
```{r}
#| label: hist-custom
#| eval: false 
#| class-source: my_class800
loans |> 
  ggplot(
    aes(x = loan_amount)
  ) +
  geom_histogram(
    binwidth = 5000,
    fill = "#003366",  
    colour = "#FFCC00",  
    alpha = 0.8,  
    linetype = "dashed"
  ) +  
  labs(
    x = "Loan amount ($)", 
    y = "Frequency", 
    title = "Lending Club loans"
  ) + 
  theme_light()
```
:::

::: {.column width="60%"}
-   `ggplot2::geom_histogram()`

```{r, ref.label = "hist-custom"}
#| echo: false
#| warning: false
#| cache: true
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also customize histograms.
-   What I did here is that I change the color of these bars with fill argument
-   And the color argument is for the edge of the bars.
-   linetype tells ggplot that the linetype of the edge of the bars is dashed line.
-   And again, we can add labels using labs function.
:::

## Fill with a Categorical Variable: Stack

::::: columns
::: {.column width="40%"}
```{r}
#| label: hist-fill
#| class-source: my_class600
#| cache: true
#| warning: false
#| fig-show: hide
loans |> 
  ggplot(
    aes(x = loan_amount,
        fill = homeownership) #<<
  ) +
  geom_histogram(
    binwidth = 5000
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Frequency"
  ) +
  theme_linedraw()
```
:::

::: {.column width="60%"}
```{r ref.label = "hist-fill"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also fill a histogram with a categorical variable, so it allows us to explore the relationship between the numerical and categorical variables.
-   This is done by adding aesthetic fill. Here basically filling the bars based on home ownership.
-   So we can actually see what's happening behind each level
:::

## Fill with a Categorical Variable: Identity (BAD)

::::: columns
::: {.column width="40%"}
```{r}
#| label: hist-fill-iden-1
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide

loans |> 
  ggplot(
    aes(x = loan_amount,
        fill = homeownership)
  ) +
  geom_histogram(
    binwidth = 5000,
    position = "identity" #<<
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Frequency",
    title = "Lending Club loans"
  ) +
  theme_minimal()
```
:::

::: {.column width="60%"}
```{r ref.label = "hist-fill-iden-1"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

. . .

::: question
Why such plot is bad?
:::

::: notes
-   So here, if we don't specify alpha, there is no transparency at all.
-   And we can see that the histogram of loan amount for house owners is totally masked by the histogram for renters, because there are much more renters than house owners, and the frequency of each bin in the histogram for the renters is higher than the frequency for the owners.
-   So use visualization carefully. Sometimes the plot does not provide more information, and sometimes it is misleading.
:::

## Fill with a Categorical Variable: Identity

::::: columns
::: {.column width="40%"}
```{r}
#| label: hist-fill-iden
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide

loans |> 
  ggplot(
    aes(x = loan_amount,
        fill = homeownership)
  ) +
  geom_histogram(
    binwidth = 5000,
    alpha = 0.5,  #<<
    position = "identity"
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Frequency",
    title = "Lending Club loans"
  ) +
  theme_minimal()
```
:::

::: {.column width="60%"}
```{r ref.label = "hist-fill-iden"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also compare the histograms of loan amount of different homeownership by simply superimposing on one to another.
-   We use position = "identity" to do that.
-   In this case, we basically put three histograms together in one plot, sharing the same x-axis and y-axis
-   If you wanna use this type of plot, remember to make it transparent, so that each histogram can be seen even they are superimposed.
:::

## Facet with a Categorical Variable

::::: columns
::: {.column width="40%"}
```{r}
#| label: hist-facet
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide
loans |> 
  ggplot(
    aes(x = loan_amount,
        fill = homeownership)
  ) +
  geom_histogram(
    binwidth = 5000
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Frequency",
    title = "Lending Club loans"
  ) +
  facet_wrap(
    ~ homeownership, #<<
    nrow = 3  #<<
  )       
```
:::

::: {.column width="60%"}
```{r ref.label = "hist-facet"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   If you don't want to put all three histograms in one single plot, remember you can use faceting trick.
-   first again I fill in with colors based on homeownership
-   Then instead of changing alpha level, and put them on top of each other, I can facet the plot.
-   Since I am using a single categorical variable to facet, I am going to use facet_wrap() function by homeownership variable and I want the data to be represented in 3 rows, so that the three histograms share the same x-axis and are compared easily. - Basically, there are not many house owners in the data set. And basically all three distributions are right-skewed.
:::

## 

::: lab
[ **13-Visualization** ]{style="color:blue"}

<!-- - Create a R script named **lab11-bar-hist.R**. -->

In **lab.qmd** `## Lab 13` section,

-   Import the data **penguins.csv**.

-   Generate the following
:::

::::: columns
::: {.column width="50%"}
```{r}
#| echo: false
library(tidyverse)
penguins <- read_csv("./data/penguins.csv")
ggplot(data = penguins, aes(x = species, fill = species)) +
    geom_bar() +
    labs(x = "Species of Penguins", 
         title = "Species Counts in Penguins Data")
```
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| warning: false
ggplot(penguins, aes(x = bill_length_mm, 
                     fill = species)) +
    geom_histogram() +
    labs(x = "Bill Length (mm)",
         y = "Frequency",
         title = "Penguins Bill Length by Species") +
    facet_wrap(~ species, nrow = 1) + 
    theme(legend.position = "none")

```
:::
:::::

## 

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
# library(tidyverse)
penguins <- read_csv(__________________)
________ |> ggplot(_______________________) +  ## mapping layer  
    ___________________ +  ## geometry layer
    _____________________________  ## label layer
```

<br> <br> <br>

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false
________ |> ggplot(______________________________) +  ## mapping layer  
    _______________ +  ## geometry layer
    _______________ +  ## label layer
    ______________________________  +   ## facet layer
    ______________________________      ## theme layer (set legend.position = "none")

```

## Density Plot

<!-- kernel = c("gaussian", "epanechnikov", "rectangular", -->

<!--                    "triangular", "biweight", -->

<!--                    "cosine", "optcosine") -->

-   `geom_density()` uses **kernel density estimation** to smooth the histogram or our data. (MATH 4750 Statistical Computing)

```{r}
#| label: den
#| out-width: 55%
#| cache: true
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_density()  #<<
```

::: notes
-   Let's continue. Another way we can visualize numerical data is using a density plot.
-   A density plot is basically a smoothed version of a histogram.
-   Remember that a continuous random variable has a continuous probability distribution that is a density curve as a plot. Right?
-   So a normal r.v. has a normal density curve that this.
-   But given a data set of continuous variable, we can only draw a histogram that is sort of an approximation to its density curve. The histogram will only be very much like its true density plot when the data size is huge or approaching to infinity.
-   A density plot here smooths the histogram, telling us that given the data set we have, what the true density curve might look like.
-   In ggplot, we have geometry geom_density() to create a density plot.
-   And ggplot uses the so-called **kernel density estimation** to smooth the histogram. The kernel is not a the linux kernel in computer science. The kernel here is a probability distribution.
-   If you are interested, it will be taught in 4750 Computational Statistics which is a new course starting this fall.
-   You can see in the graph that the density curve smooths the histogram, but it;s still not very smooth, right. It's a little bit jagged.
-   The ggplot choose a level of smoothness for us. And we can adjust the smoothness by ourselves.
:::

## Density Plots and Adjusting Bandwidth

::: panel-tabset
## adjust = 0.5

```{r}
#| label: den05
#| out-width: 65%
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_density(adjust = 0.5)
```

## adjust = 1

```{r}
#| label: den1
#| out-width: 65%
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_density(adjust = 1) # default bandwidth
```

## adjust = 2

```{r}
#| label: den2
#| out-width: 65%
#| code-line-numbers: false
ggplot(loans, aes(x = loan_amount)) +
    geom_density(adjust = 2)
```
:::

::: notes
-   We can adjust the smoothness of a density plot by the argument adjust in geom_density() function.
-   basically, the larger the value is, the smoother the curve will be.
-   and the default is adjust = 1.
-   Keep in mind that if you use a very smooth density plot, some local peaks or features may be washed out or smoothed away. If these local things contain some information, you may lose the information by just looking at the smooth density plot.
-   So a better idea is to try different level of smoothness, and check different plots, such as histogram, bar plots, and scatter plots as well.
:::

## Customizing Density Plots {visibility="hidden"}

::::: columns
::: {.column width="40%"}
```{r}
#| label: density-custom
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide
loans |> 
  ggplot(
    aes(x = loan_amount)
  ) +
  geom_density(
    adjust = 2,
    fill = "#FFCC00", 
    color = "#003366", 
    alpha = 0.5, 
    linetype = "dashed"
  ) + 
  labs(
    x = "Loan amount ($)", 
    y = "Density", 
    title = "Lending Club loans"
  ) 
```
:::

::: {.column width="60%"}
-   `ggplot2::geom_density()`

```{r ref.label = "density-custom"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also customize density plots as others.
-   In addition to adjust, we can also use fill, color, alpha, line type as we have used in histogram.
:::

## Density Curve on a Histogram {visibility="hidden"}

::::: columns
::: {.column width="40%"}
```{r density-hist}
#| label: density-hist
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide
loans |> 
  ggplot(
    aes(x = loan_amount)
  ) + 
  ## scale down to 
  ## match the density
  geom_histogram(
    binwidth = 5000, 
    aes(y = after_stat(density)) #<<
  ) + 
  geom_density(
    alpha = 0.1, 
    fill = "#FF6666"
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Density",
    title = "Lending Club loans"
  )

```
:::

::: {.column width="60%"}
```{r ref.label = "density-hist"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   Sometimes we like to put the density on top of the histogram to have a better understanding how smooth the density curve is, comparing to the histogram.
-   Well it's very easy to do that.
-   We just need to add the geom_density layer to the existent geom_histogram layer.
-   And don't forget to use density scale in geom_histogram so that the height of histogram and density plot can share the same y-axis each other.
:::

## Adding a Categorical Variable to Density Plots

::::: columns
::: {.column width="40%"}
```{r}
#| label: density-cat
#| class-source: my_class800
#| cache: true
#| warning: false
#| fig-show: hide
loans |> 
  ggplot(
    aes(x = loan_amount,
        fill = homeownership)
  ) +
  geom_density(
    adjust = 2,
    alpha = 0.4
  ) +
  labs(
    x = "Loan amount ($)",
    y = "Density",
    title = "Amounts of loans",
    fill = "Homeownership"
  )
```
:::

::: {.column width="60%"}
```{r ref.label = "density-cat"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also add a categorical variable to a density plot. This is similar to what we did with the histograms, where you can see them overlaid on top of each other.
-   So once again, we can fill in the density curves based on the value of homeownership.
-   and I am changing alpha, so that we can actually see what's happening behind the curve. If I didn't change alpha, we are not able to see the peaks of mortagage and own because they are masked by the density curve of home renters. OK.
:::

## Box Plot {visibility="hidden"}

```{r}
#| cache: true
#| warning: false
#| fig-show: hide
#| fig-cap: "Source: https://www.leansigmacorporation.com/box-plot-with-minitab/"
#| purl: false
#| echo: false
knitr::include_graphics("./images/10-viz/boxplot.png")
```

::: notes
-   OK. Again boxplot, which is another way to visualize numerical data.
-   Jut show you the meaning of each part of the boxplot that you already learned in MATH 4720.
:::

## Box Plot

```{r, echo=2:3}
#| label: box
#| cache: true
#| out-width: 73%
#| code-line-numbers: false
# coord_flip()
loans |> ggplot(aes(x = interest_rate)) +
  geom_boxplot() +
  labs(x = "interest rate (%)")
```

::: notes
-   Remember in base R, we can use boxplot function to create a boxplot.
-   In ggplot, we add the geometry layer, geom_boxplot().
-   One of things that boxplots are good at is uncovering our potential outliers, and here, the distribution of interest rates is right-skewed, and has several outliers.
-   Most of the interest rates are between 10 to 15%, but some can be as high as 30% or more.
:::

## Customizing Box Plots {visibility="hidden"}

::::: columns
::: {.column width="45%"}
```{r}
#| label: box-custom
#| fig-show: hide
#| warning: false
#| class-source: my_classfull
loans |> 
  ggplot(aes(x = interest_rate)) +
  geom_boxplot(
    # custom outliers
    outlier.colour = "red",
    outlier.shape = 8,
    outlier.size = 3,
    # Notch?
    notch = TRUE,
    notchwidth = 0.1,
    # custom boxes
    fill = "#FFCC00",
    colour = "#003366",
    alpha = 0.2
  ) +
  labs(
    x = "Interest rate (%)",
    title = "Interest rates of loans"
  ) +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  )
```
:::

::: {.column width="55%"}
-   `ggplot2::geom_boxplot()`

```{r ref.label = "box-custom"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   How do we customize our boxplot?
-   For a boxplot, we can change outlier's color, shape and size, using outlier.colour, outlier.shape and outlier.size.
-   I remembered I show you point shape and its corresponding number when I introduced base R plotting. You can use the same point shape numbering system here.
-   You can also decide if the boxplot has a notch, although I don't see the importance of this option.
-   And again you can customize the box using fill, color, and alpha argument.
-   And one interesting part is that, when we show a boxplot like this, the y-axis does not mean anything right? the width or height of the box does not meaning anything.
-   So we can actually remove the y axis tick marks and labels.
-   And how? Because the axes labels and ticks are part of plotting theme, we should go to theme and set ticks.y and text.y = element_blank().
-   This is very ggplot2 syntax. It is a little bit harder to read and make sense of, so it does take time to get used to it.
:::

## Adding a Categorical Variable to Box Plots

::::: columns
::: {.column width="45%"}
```{r}
#| label: box-cat
#| fig-show: hide
#| warning: false
#| cache: true
#| class-source: my_class600
loans |> 
  ggplot(
    aes(x = interest_rate,
        y = grade) #<<
  ) + 
  geom_boxplot() +
  labs(
    x = "Interest rate (%)",
    y = "Grade",
    title = "Interest Rates of Loans",
    subtitle = "by grade of loan"
  )
```
:::

::: {.column width="55%"}
```{r ref.label = "box-cat"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   We can also add categorical variable to a boxplot, so these are called side-by-side boxplots. They are very commonly used.
-   This is the interest rate distribution by the grade of loan, where A is of the highest quality and G is the lowest quality.
-   And it looks like the higher the quality of the loan, the lower the interest rate it has.
-   We can also see that there is an outlier in grade D data, where the interest rate is super low, even lower than most of the interest rate of the grade A loans. You as a reasearcher or data analyst have to figure out if it is typo, or it is the true interest rate. If it is a correct number, why such low interest rate happened?
-   And to create such side-by-side boxplot, we just add y mapping, setting it to grade.
:::

## Adding Two Categorical Variables to Box Plots

::::: columns
::: {.column width="40%"}
```{r}
#| label: box-cat-2
#| fig-show: hide
#| warning: false
#| cache: true
#| class-source: my_class800
loans |> 
  ggplot(
    aes(x = interest_rate,
        y = grade,
        fill = homeownership) #<<
  ) +
  geom_boxplot() +
  labs(
    x = "Interest rate (%)",
    y = "Grade",
    fill = "Homeowership",
    title = "Interest Rates of Loans",
    subtitle = "by grade and ownership"
  ) +
  theme(
    legend.position = "bottom"
  )
```
:::

::: {.column width="60%"}
```{r ref.label = "box-cat-2"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

::: notes
-   If we want to add two categorical variables to box plots, that's easy.
-   We can fill the boxplots with colors based on another variable, here the homeownership.
-   ANd now each grade of loans is furthered divided into three categories of the homeownership variable.
-   And we can see that basically, the type of homeownership does not affect interest rate much given the same grade of loans.
:::

## Adding Points on Box Plots {visibility="hidden"}

```{r}
#| label: box-pt
#| out-width: 72%
#| cache: true
#| code-line-numbers: false
ggplot(loans, aes(x = homeownership, y = interest_rate)) +
    geom_boxplot() +
    geom_point(alpha = 0.1, shape = 1) #<< geom_jitter(width = 0.2, alpha = 0.1, shape = 1)

```

::: notes
-   If we don't just want the boxplot, and we also want to show data points along with the boxplot, we can add the another layer geom_point(), as shown here.
-   But this plot is a little misleading. Anybody see why?
-   The boxplot tell us 50% of the data points should be inside the box, right?
-   But according to the boxplot, it is not the case. Why?
-   Actually, there are lots points overlapped at the same interest rate. So it looks like there is only one data point, but actually there are many data points right there. They just overlapped each other.
-   So how do we actually show all data points?
:::

# Relationships between numerical variables {background-color="#A7D5E8"}

## Scatterplot

```{r}
#| label: scatter
#| out-width: 72%
#| cache: true
#| code-line-numbers: false
#| warning: false
ggplot(loans, aes(x = debt_to_income, y = interest_rate)) +
    geom_point(shape = 23, fill = "blue", size = 0.8)  #<<
```

::: notes
-   We already talked about scatter plot using geom_point().
-   Here we have a scatter plot of interest rate and the debt to income ratio.
-   One potential problem here is that like adding points to boxplot, we have so many data points overlapped together, and their relationship cannot be truly revealed. and so it's really difficult to make sense of this scatter plot built with geom_point.
:::

## Hex Plot {visibility="hidden"}

```{r}
#| label: hex
#| out-width: 72%
#| cache: true
#| code-line-numbers: false
#| warning: false
library(hexbin)
ggplot(loans, aes(x = debt_to_income, y = interest_rate)) +
    geom_hex()  #<< (hexbin pkg)
```

::: notes
-   So one solution is using Hex Plot instead by using geom_hex() function.
-   The idea is that we first bin these data with the hex shape, grouping data points together for each hex bin.
-   And the color of these hexes is what tells us how many data points or how dense my data are.
-   So the lighter the color, the more data points we have there.
-   This is particularly useful when we have lots of data points that have similar or the same values.
:::

## Hex Plot Zoom-in

```{r}
#| label: hex-zoom
#| out-width: 62%
#| cache: true
#| code-line-numbers: false
#| warning: false
loans |> 
    filter(debt_to_income < 100) |> 
    ggplot(aes(x = debt_to_income, y = interest_rate)) +
    geom_hex() +
    viridis::scale_fill_viridis()
```

::: notes
-   Here just show you that we can further zoom in the plot, focusing on the the data that has debt_to_income ratio less that 100%.
-   And now we can more clearly see what's going on.
-   Basically, more data points happen around debt_to_income ratio 12 to 15% and interest rate 10%.
-   And the two variables are a little bit positively correlated that higher debt_to_income ratio corresponds to higher interest rate. But again the correlation is very weak here.
:::

# Other Plots {background-color="#A7D5E8"}

## Line Chart for Time Series `ggplot2::geom_line()`

```{r}
#| label: line
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
economics_long |> ggplot(aes(x = date, y = value01, 
                             colour = variable, linetype = variable)) +
    geom_line(linewidth = 1) + 
    theme_bw() +
    theme(legend.position = "bottom")
```

::: notes
-   If you have time series data, line plot is your good friend, which shows the trend of some variable.
-   For example here, the unemployment number.
:::

## QQ-plots

-   Quantile-Quantile plots are used to check if data are normally distributed (or follow any distribution).

```{r}
#| label: qq
#| out-width: 70%
#| cache: true
#| code-line-numbers: false
ggplot(mpg, aes(sample = hwy)) + geom_qq() + geom_qq_line()
```

::: notes
-   To create a qqplot, we add the geometry geom_qq(), and geom_qq_line() if you want to add a straight line that helps you determine whether the data are normally distributed.
:::

## Violin Plots

-   Violin plots are similar to box plots, but show the smooth density of the data.

```{r}
#| code-line-numbers: false
f <- ggplot(loans, aes(x = loan_amount, y = grade))
```

::::: columns
::: {.column width="50%"}
```{r}
#| code-line-numbers: false
f + geom_boxplot()
```
:::

::: {.column width="50%"}
```{r}
#| label: violin
#| code-line-numbers: false
f + geom_violin() 
```
:::
:::::

::: notes
<!-- + geom_boxplot(width = 0.2) -->

-   In ggplot, we can use geom_violin() to create one. <!-- - Basically Violin Plots contain more information because we also have the density or distribution of the data. -->
-   See if we just check the boxplot, we will miss the information that the loan amount of the grade G actually has a bimodal distribution, right?
:::

## Add-on `r emo::ji("package")`: [`ggridges`](https://wilkelab.org/ggridges/) for Ridge Plots

```{r}
#| label: ridges
#| warning: false
#| cache: true
#| code-line-numbers: false
library(ggridges)
ggplot(loans, aes(x = loan_amount, y = grade, fill = grade, color = grade)) +
    geom_density_ridges(alpha = 0.9)
```

::: notes
-   To show better smooth density plots, we can create the so-called ridge plots provided by the add-on package called ggridges.
-   everything is basically the same. You just need to install and load the package, and add the geometry called geom_density_ridges().
:::

## Add-on `r emo::ji("package")`: [`ggrepel`](https://ggrepel.slowkow.com/) ![](https://raw.githubusercontent.com/slowkow/ggrepel/master/man/figures/logo.svg){width="50"}

-   **ggrepel** provides geoms for ggplot2 to repel overlapping text labels.

```{r}
#| label: ggrepel0
#| cache: true
#| code-line-numbers: false
library(ggrepel)
p <- mtcars |> filter(wt > 2.75 & wt < 3.45) |> rownames_to_column("car") |> 
    ggplot(aes(wt, mpg, label = car)) +
    geom_point(color = "red")
```

::::: columns
::: {.column width="50%"}
```{r}
#| label: ggrepel1
#| cache: true
#| out-width: 100%
#| code-line-numbers: false
p + geom_text() + 
    labs(title = "geom_text()")
```
:::

::: {.column width="50%"}
```{r}
#| label: ggrepel2
#| cache: true
#| out-width: 100%
#| code-line-numbers: false
p + geom_text_repel() + 
    labs(title = "geom_text_repel()")
```
:::
:::::

::: notes
-   Another useful ggplot2 extension is ggrepel that provides geoms for ggplot2 to repel overlapping text labels.
-   This makes your labels much more clear.
-   For example, here I want to label each data point by its observation's name, I can add geom_text(). But the ggplot2 setting basically put the text right on the top of the point, which sometimes the labels are mixed together and makes it hard to read.
-   And we can use the function geom_text_repel(), and then it will automatically find a good spot for those texts that are close to their data point, but not overlap each other.
:::

## Wordcloud from [`ggwordcloud`](https://lepennec.github.io/ggwordcloud/) Package ![](https://raw.githubusercontent.com/lepennec/ggwordcloud/master/man/figures/logo.png){width="50"}

::: panel-tabset
## Plot

```{r ref.label = "wordcloud"}
#| echo: false
#| cache: false
#| warning: false
#| out-width: 100%
#| purl: false
```

## Code

```{r}
#| label: wordcloud
#| fig-show: hide
#| cache: false
#| code-line-numbers: false
library(ggwordcloud)
library(showtext)
where <- font_files()[which(str_detect(font_files()$family, "Arial Unicode MS")), ]
par(mar = c(0, 0, 0, 0))
thankyou_words_small |> ggplot(aes(label = word, size = speakers, color = name)) + 
    geom_text_wordcloud(area_corr = TRUE, rm_outside = TRUE, 
                        family = where[1, ]$family) +
    scale_size_area(max_size = 40) + 
    theme_minimal() +
    theme(plot.margin = margin(t = -200,  # Top margin
                               r = 0,  # Right margin
                               b = 0,  # Bottom margin
                               l = 0)) # Left margin
```
:::

::: notes
https://towardsdatascience.com/create-a-word-cloud-with-r-bde3e7422e8a http://www.sthda.com/english/wiki/text-mining-and-word-cloud-fundamentals-in-r-5-simple-steps-you-should-know http://www.sthda.com/english/wiki/word-cloud-generator-in-r-one-killer-function-to-do-everything-you-need https://semba-blog.netlify.app/10/29/2019/creating-wordcloud-in-r/ <!-- install.packages("tm")  # for text mining --> <!-- install.packages("SnowballC") # for text stemming --> <!-- install.packages("wordcloud") # word-cloud generator  --> <!-- install.packages("RColorBrewer") # color palettes --> https://stackoverflow.com/questions/74415534/why-do-characters-from-foreign-alphabets-not-show-in-my-wordcloud-on-r
:::

## Radar Chart from [`fmsb`](https://r-charts.com/ranking/radar-chart/) and [`ggradar`](https://github.com/ricardo-bion/ggradar) Package

::::::::::: panel-tabset
## Plot

::::: columns
::: {.column width="50%"}
```{r ref.label = "radar"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::

::: {.column width="50%"}
```{r ref.label = "ggradar"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 100%
#| purl: false
```
:::
:::::

## Code

::::::: columns
:::: {.column width="50%"}
::: midi
```{r, echo=-1}
#| label: radar
#| fig-show: hide
#| cache: false
#| class-source: my_classfull
library(fmsb)
radar_data <- readr::read_csv(
    file = "./data/radar_data.csv")
# Color vector
colors_border <- c(rgb(0.2,0.5,0.5,0.9), 
                   rgb(0.8,0.2,0.5,0.9), 
                   rgb(0.7,0.5,0.1,0.9))
colors_in <- c(rgb(0.2,0.5,0.5,0.4), 
               rgb(0.8,0.2,0.5,0.4), 
               rgb(0.7,0.5,0.1,0.4))
par(mar = c(0, 0, 0, 0))
radarchart(radar_data, axistype = 1, 
           #custom polygon
           pcol = colors_border, 
           pfcol = colors_in, 
           plwd = 4, plty = 1,
           #custom the grid
           cglcol = "grey", cglty = 1, 
           axislabcol = "grey", 
           caxislabels = seq(0, 20, 5), 
           cglwd = 0.8,
           #custom labels
           vlcex = 1.2)
# legend("topright", legend = rownames(radar_data[-c(1, 2), ]), bty = "n", pch = 20 , 
#        col = colors_in, text.col = "grey", cex = 1.2, pt.cex = 3)
```
:::
::::

:::: {.column width="50%"}
::: midi
```{r}
#| label: ggradar
#| fig-show: hide
#| cache: false
#| class-source: my_classfull
library(ggradar)

ggradar_data <- radar_data |>
    as_tibble(rownames = "group") |>
    mutate_at(vars(-group), rescale) |>
    tail(3)
par(mar = c(0, 0, 0, 0))
ggradar(ggradar_data,
        base.size = 5,
        grid.label.size = 6,
        axis.label.size = 5,
        group.point.size = 3,
        fill.alpha = 0.2,
        grid.line.width = 0.4,
        plot.legend = FALSE,
        fill = TRUE)
```
:::
::::
:::::::
:::::::::::

::: notes
lazy-load database '/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/callr/R/callr.rdb' is corrupt Restart R
:::

## Network from [`igraph`](https://igraph.org/r/) Package

::: panel-tabset
## Plot

```{r ref.label = "network"}
#| echo: false
#| cache: true
#| warning: false
#| out-width: 65%
#| purl: false
```

## Code

```{r, echo=-1}
#| label: network
#| fig-show: hide
#| cache: true
#| code-line-numbers: false

par(mar = c(1, 0, 0, 0))
library(igraph)
network_data <- read_rds(file = "./data/network_data.rds")

# build the graph object
network <- graph_from_adjacency_matrix(network_data)

# plot it
plot(network)
```
:::

## More R Graphics Resources

-   More add-on `r emo::ji("package")`: [ggplot2 extensions](https://exts.ggplot2.tidyverse.org/gallery/)
-   [The R Graph Gallery](https://www.r-graph-gallery.com/index.html)
-   [R Graphics Cookbook](https://r-graphics.org/)
-   [R CHARTS](https://r-charts.com/)

```{r}
#| echo: false
knitr::include_graphics("./images/10-viz/ggextension.png")
```

::: notes
-   As I mentioned before, there are tons of ggplot2 extensions.
-   If you are interested, check those links, and learn more about them. OK.
:::
